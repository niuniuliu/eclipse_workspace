1。重写
重写：顾名思义，重新实现，等同于“覆盖”的概念
重写的背景
比如张三写了一个类，并提供给其他同事使用
后来，发现这个类的一些方法的实现不够高明，需要重新实现
这个任务可能不再是原作者张三来承担，比如是项目经理承担了这份代码重新的工作，项目经理不会去直接改动张三的代码，当然，也不应该是直接修改别人的东西，怎么办---重写，先继承，再覆盖


实现过程：
A。编写新类（B类）继承该类（A类）
B。在B类中，写出一个同名称，同参数，同返回值的方法
C。在B类的重写方法中，重新编写新的代码


重写的规则；
A。重写方法和被重写方法具有同名称，同参数，同返回值
B。子类的重写方法应该比父类的被重写方法具有更高的访问控制权限，也就是访问控制应该放大，或者相同


2。构造函数
构造函数是一个特殊的函数（方法）应该有（）
构造函数也被称为：
构造函数
构造方法
构造子
构造器

构造函数可以被重载

构造函数的相互调用：
使用this关键字可以实现构造函数的相互调用
this();

构造函数不能被继承


使用super调用父类构造函数

A.在子类中,可以通过super()来调用父类的构造函数
B.super()只能在子类的构造函数中被调用
public TestC(){
		super(5);
}
	


3.super关键字的使用
使用super关键词可以调用父类中的成员
A.使用super可以调用父类的构造函数
B.使用super可以调用父类的属性
C.使用super可以调用父类的方法



4.多态
当我们需要创建一个父类的对象的时候,我们可以将创建出来的子类对象赋给它,这种现象在语法上被称为"多态".
通俗的说:就是子类对象使用打他爹的招牌


5.final修饰符
final修饰类:该类不能不继承
final修饰方法:该方法不能重写
final修饰变量:该变量被称为常量,常量的值不能被二次赋值


6.初始化代码块
在代码块前面加上static修饰符,则该代码块只会被执行一次
理解继承中的静态自由块的执行顺序

7.==比较符号和equals方法的使用
判断两个简单数据的值或者两个对象是否相等。
	==用来判断两个简单数据类型的变量是否相等，或者两个应用数据类型的变量（对象）是否指向同一个内存地址。
	而equals()用来比较两个对象的值是否相同。（所谓值相同是值属性值相同，且是同一个类的对象）

if(str.equals("abc"))
if("abc".equals(str))

8.API ---- Object类

	toString()
	原始的toString()内部的代码是：
	   Return getClass().getName()+”@”+Integer.toHexString(hashCode());
	如果String类型与其他类型进行+连接的时候，有两种情况
?	  与引用型数据类型连接，应用类型数据调用其toString()方法返回字符串后与之连接。
?	  与简单类型数据连接，简单类型数据先转化为对应的封装类，然后调用toString()方法
	  返回字符串后与之连接
	equals()
	  覆盖equals()方法
	  Object类中定义了equals()方法，但是是为了判断两个类是否指向同一个对象，对于值的比较是不适用的，必须override这个方法

9.封装类
根据java一直追求的原则:一切皆对象
java对那些不是对象的基本类型,如int,short,boolean等,对这些类型提供了一个面向对象的表示,就是封装类
int----Integer
boolean----Boolean
double-----Double
提供封装类的目的,就是为了方便的完成各种数据类型的转换等操作


































